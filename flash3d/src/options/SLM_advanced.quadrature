!*****************************************************************
!
! MODULE NAME:
!	SLM_advanced
! FUNCTION:
!	provide simple semi-Lagrangian routines
! CONTAINS:
!-----------------------------------------------------------------
!
! NAME:
!	slm_astep
! FUNCTION:
!	one step of the basic SLM algorithm
! SYNTAX:
!	CALL slm_astep(int, real.arr, real.arr)
! ON INPUT:
!	...
! ON OUTPUT:
!	r_tracer: array with tracer values	real
! CALLS:
!
! COMMENTS:
!
!-----------------------------------------------------------------
!
! NAME:
!	slm_adisplace
! FUNCTION:
!	extrapolate the alpha, values for the displacements of the upstream
!	points from the gridpoints
! SYNTAX:
!	CALL slm_adisplace(int, real.arr, real.arr)
! ON INPUT:
!	i_arlen: array length for the real arrays	integer
!	r_coord: real array of xy-coordinates		real
! ON OUTPUT:
!	r_alpha: displacement vectors to each point	real
! CALLS:
!	wind_field
! COMMENTS:
!
!-----------------------------------------------------------------
!
! NAME:
!	slm_aupdate
! FUNCTION:
!	calculate the update to the velocity
! SYNTAX:
!	CALL slm_aupdate(int, real.arr, real.arr)
! ON INPUT:
!	i_arlen: array length for the real arrays	integer
!	r_rside: array with right hand side values	real
! ON OUTPUT:
!	r_udate: array with new (updated) gid values	real
! CALLS:
!
! COMMENTS:
!	this routine is trivial for linear advection
!
!-----------------------------------------------------------------
!
! NAME:
!	slm_aupstream
! FUNCTION:
!	calculate right hand side of the equation (upstream values)
! SYNTAX:
!	CALL slm_aupstream(int, real.arr, real.arr)
! ON INPUT:
!	i_arlen: array length for the real arrays	integer
!	r_alpha: displacement vectors to each point	real
! ON OUTPUT:
!	r_rside: array with right hand side values	real
! CALLS:
!
! COMMENTS:
!	this routine is just interpolation for linear advection
!
!-----------------------------------------------------------------
!
! NAME:
!	slm_ainterpolate
! FUNCTION:
!	do the interpolation
! SYNTAX:
!	CALL slm_ainterpolate(grid, int, real, real.arr, real.arr, real.arr)
! ON INPUT:
!	p_ogrid: grid handle to old grid (with data)	TYPE (grid_handle)
!	r_fac:   factor at which point to interpolate	REAL
!	i_arlen: array length for the following arrays	INTEGER
!	r_coord: coordinate array (new grid)		REAL
!	r_alpha: displacement array (corr. to r_coord)	REAL
!	r_value: values on the old grid (array)		REAL
! ON OUTPUT:
!	r_rside: right hand side (interpolated)		REAL
! CALLS:
!
! COMMENTS:
!	this one is plain bi-cubic spline interpolation
!
!-----------------------------------------------------------------
!
! PUBLIC:
!	slm_astep
! COMMENTS:
!
! USES:
!	FLASH_parameters, GRID_api, ADV_wind, ADV_rhs
! LIBRARIES:
!
! REFERENCES:
!
! VERSION(S):
!	1. original version		j. behrens	12/2002
!
!*****************************************************************
	MODULE SLM_advanced
	  USE FLASH_parameters
	  USE MISC_timing
	  USE GRID_api
	  USE ADV_wind
	  USE ADV_rhs
	  PRIVATE
	  PUBLIC  :: slm_astep
	  CONTAINS
!*****************************************************************
	  SUBROUTINE slm_astep(p_ghand, p_param, p_time, r_modtime, i_size, &
	                       r_coord, r_tracer)

!---------- local declarations

	  IMPLICIT NONE

	  TYPE (grid_handle), DIMENSION(GRID_timesteps), INTENT(in) :: p_ghand
	  TYPE (control_struct), INTENT(in)                         :: p_param
	  TYPE (sw_info), INTENT(inout)                             :: p_time
	  REAL, INTENT(in)                                          :: r_modtime
	  INTEGER, INTENT(in)                                       :: i_size
	  REAL, DIMENSION(GRID_dimension,i_size), INTENT(in)        :: r_coord
	  REAL, DIMENSION(i_size), INTENT(out)                      :: r_tracer
	  
	  REAL, DIMENSION(:), ALLOCATABLE                           :: r_newvl
	  REAL, DIMENSION(:,:), ALLOCATABLE                         :: r_alpha
	  INTEGER                                                   :: i_alct
	  REAL, DIMENSION(:,:), POINTER                             :: r_dualcoordinates
	  REAL, DIMENSION(:,:), POINTER                             :: r_dualalpha
	  INTEGER, DIMENSION(:,:,:), POINTER                        :: i_dualfaces
	  INTEGER                                                   :: i_dual


!---------- check size!

	  IF(i_size <= 0) THEN
	    IF(GRID_parameters%iolog > 0) &
	      write(GRID_parameters%iolog,*) 'INFO [slm_astep]: Zero step size, returning to calling routine'
	    RETURN
	  END IF

!---------- allocate auxiliary arrays

	  allocate(r_newvl(i_size), r_alpha(GRID_dimension,i_size), stat=i_alct)
	  IF(i_alct /= 0) CALL grid_error(c_error='[slm_astep]: could not allocate aux. arrays')

!---------- create dual mesh

	  CALL grid_createdual(p_ghand(i_timeplus), i_size, i_dual, i_dualfaces, &
	                       r_dualcoordinates)

!---------- allocate array for dual displacements

	  allocate(r_dualalpha(GRID_dimension,i_dual), stat=i_alct)
	  IF(i_alct /= 0) CALL grid_error(c_error='[slm_astep]: could not allocate dual arrays')

!-SLM--------- calculate trajectory pieces (displacements)

	  CALL stop_watch('start',3,p_time)
	  CALL slm_adisplace(p_param, i_size, r_coord, r_alpha, &
	  		    i_dual, r_dualcoordinates, r_dualalpha, r_time=r_modtime)
	  CALL stop_watch('stop ',3,p_time)

!-SLM--------- calculate right hand side

	  CALL stop_watch('start',4,p_time)
	  CALL slm_aupstream(p_ghand, i_size, r_coord, r_alpha, &
	  		    i_dual, r_dualcoordinates, r_dualalpha, &
	  		    i_dualfaces, r_newvl)
	  CALL stop_watch('stop ',4,p_time)

!-SLM--------- calculate new grid values

	  CALL stop_watch('start',5,p_time)
	  CALL slm_aupdate(p_param, i_size, r_coord, r_newvl, r_tracer, r_time=r_modtime)
	  CALL stop_watch('stop ',5,p_time)

!---------- destroy dual mesh

	  CALL grid_destroydual(i_dual, i_dualfaces, r_dualcoordinates)

!-SLM--------- put alpha values to u and v field entries

	  r_alpha= -r_alpha
	  CALL grid_putinfo(p_ghand(i_timeplus), i_size, r_nodevalues=r_alpha(1,:), &
	                    i_valpoint=GRID_ucomp)
	  CALL grid_putinfo(p_ghand(i_timeplus), i_size, r_nodevalues=r_alpha(2,:), &
	                    i_valpoint=GRID_vcomp)
	  CALL grid_putinfo(p_ghand(i_timeplus), i_size, r_nodevalues=r_alpha(3,:), &
	                    i_valpoint=GRID_wcomp)

!-SLM--------- deallocate work arrays

	  deallocate(r_alpha, r_newvl, r_dualalpha)

	  RETURN
	  END SUBROUTINE slm_astep
!*****************************************************************
	  SUBROUTINE slm_adisplace(p_param, i_arlen, r_coord, r_alpha, &
	                          i_darlen, r_dcoord, r_dalpha, r_time)

!---------- local declarations

	  IMPLICIT NONE

	  TYPE (control_struct), INTENT(in)                     :: p_param
	  INTEGER, INTENT(in)                                   :: i_arlen
	  REAL, DIMENSION(GRID_dimension,i_arlen), INTENT(in)   :: r_coord
	  REAL, DIMENSION(GRID_dimension,i_arlen), INTENT(out)  :: r_alpha
	  INTEGER, INTENT(in)                                   :: i_darlen
	  REAL, DIMENSION(GRID_dimension,i_darlen), INTENT(in)  :: r_dcoord
	  REAL, DIMENSION(GRID_dimension,i_darlen), INTENT(out) :: r_dalpha
	  REAL, INTENT(in), OPTIONAL                            :: r_time
	  REAL, DIMENSION(GRID_dimension)                       :: r_fac, r_caf, &
	    r_axy, r_xyc
	  REAL                                                  :: r_dt0, r_dt1, &
	    r_dt2, r_tim
	  INTEGER                                               :: i_cnt1, i_cnt2
          
!---------- set constants

	  r_dt0= p_param%phy%r_deltatime
	  r_dt1= 0.5* p_param%phy%r_deltatime
	  r_dt2= 1.5* p_param%phy%r_deltatime
	  r_fac= 0.5
	  r_caf= 2.0
	  IF(present(r_time)) THEN
	    r_tim= r_time
	  ELSE
	    r_tim= 0.0
	  END IF

!---------- calculate in an iteration process the displacements

	  unknown_loop: DO i_cnt1=1,i_arlen
	    r_axy= 0.0

	    iter_loop: DO i_cnt2=1, p_param%phy%i_adviterations
	      r_xyc= r_coord(:,i_cnt1)- r_fac* r_axy
	      r_axy= r_dt0* slm_windfield(r_xyc, r_time=r_tim)
	    END DO iter_loop

	    r_alpha(:,i_cnt1)= r_axy
	  END DO unknown_loop

!---------- the same for the dual grid

	  dual_loop: DO i_cnt1=1,i_darlen
	    r_axy= 0.0

	    diter_loop: DO i_cnt2=1, p_param%phy%i_adviterations
	      r_xyc= r_dcoord(:,i_cnt1)- r_fac* r_axy
	      r_axy= r_dt0* slm_windfield(r_xyc, r_time=r_tim)
	    END DO diter_loop

	    r_dalpha(:,i_cnt1)= r_axy
	  END DO dual_loop

	  RETURN
	  END SUBROUTINE slm_adisplace

!*****************************************************************
	  SUBROUTINE slm_aupdate(p_param, i_arlen, r_coord, r_rside, r_udate, r_time)

!---------- local declarations

	  IMPLICIT NONE

	  TYPE (control_struct), INTENT(in)                   :: p_param
	  INTEGER, INTENT(in)                                 :: i_arlen
	  REAL, DIMENSION(GRID_dimension,i_arlen), INTENT(in) :: r_coord
	  REAL, DIMENSION(i_arlen), INTENT(in)                :: r_rside
	  REAL, DIMENSION(i_arlen), INTENT(out)               :: r_udate
	  REAL, INTENT(in), OPTIONAL                          :: r_time
	  INTEGER                                             :: i_cnt
	  REAL                                                :: r_dt, r_tim

!---------- in the linear advection case and with f90 this is just

!	  r_udate= r_rside

!---------- including a non-zero right hand side, we have

	  r_dt= p_param%phy%r_deltatime
	  IF(present(r_time)) THEN
	    r_tim= r_time
	  ELSE
	    r_tim= 0.0
	  END IF

	  main_loop: DO i_cnt=1, i_arlen
	    r_udate(i_cnt)= r_rside(i_cnt)+ r_dt* slm_righthand(r_coord(:,i_cnt))
	  END DO main_loop

	  RETURN
	  END SUBROUTINE slm_aupdate


!*****************************************************************
	  SUBROUTINE slm_aupstream(p_mesh, i_arlen, r_coord, r_alpha, &
	                           i_darlen, r_dcoord, r_dalpha, &
	                           i_dface, r_rside)

!---------- local declarations

	  IMPLICIT NONE

	  TYPE (grid_handle), DIMENSION(GRID_timesteps)        :: p_mesh
	  INTEGER, INTENT(in)                                  :: i_arlen
	  REAL, DIMENSION(GRID_dimension,i_arlen), INTENT(in)  :: r_coord
	  REAL, DIMENSION(GRID_dimension,i_arlen), INTENT(in)  :: r_alpha
	  INTEGER, INTENT(in)                                  :: i_darlen
	  REAL, DIMENSION(GRID_dimension,i_darlen), INTENT(in) :: r_dcoord
	  REAL, DIMENSION(GRID_dimension,i_darlen), INTENT(in) :: r_dalpha
	  INTEGER, DIMENSION(:,:,:), INTENT(in)                :: i_dface
	  REAL, DIMENSION(i_arlen), INTENT(out)                :: r_rside
	  INTEGER                                              :: i_alct, i_cnt, &
	    j_cnt, i_tnc, i_oarlen, i_fill, i_len, i_tmp, i_dimcnt, i_faccnt, i_wcnt
	  REAL, DIMENSION(GRID_dimension)		       :: r_1, r_2, r_3
	  REAL  					       :: r_oarea, r_nvolume
	  REAL, DIMENSION(:,:,:), ALLOCATABLE		       :: r_aux1
	  REAL, DIMENSION(:,:), ALLOCATABLE		       :: r_aux2
	  REAL, DIMENSION(:), ALLOCATABLE		       :: r_mass
	  REAL  					       :: r_onethird=1./3.
	  INTEGER, DIMENSION(GRID_patchelements)               :: i_polynod
	  REAL, DIMENSION(GRID_dimension,GRID_tetranodes)      :: r_vertx
	  REAL  					       :: r_part, r_isarea
	  REAL, EXTERNAL				       :: triatria_isectar
	  REAL  					       :: r_xmax, r_ymax, r_xmin, r_ymin
	  REAL  					       :: r_maxx, r_maxy, r_minx, r_miny
	  REAL  					       :: r_val, r_intgrl
	  INTEGER, DIMENSION(:), POINTER                       			:: i_triang
	  REAL, DIMENSION(:), POINTER                          :: r_area

	  i_faccnt= size(i_dface,DIM=2)

!---------- main loop over the nodes of the new grid

	  WRITE(*,1000,ADVANCE='NO')
	  i_wcnt= i_arlen/49
	  node_loop: DO i_cnt=1,i_arlen
	    IF(mod(i_cnt,i_wcnt) == 1) THEN
! 	    IF(mod(i_cnt,25) == 1) THEN
	      WRITE(*,1010,ADVANCE='NO') !(100.*i_cnt)/i_arlen
	    END IF
	    r_val= 0.0
	    r_nvolume= 0.0
	    r_vertx= 0.0

!---------- the upstream dual element's center node
	    
	    DO i_dimcnt = 1, GRID_dimension
	      r_vertx(i_dimcnt,1)= r_coord(i_dimcnt,i_cnt)- r_alpha(i_dimcnt,i_cnt)
	    END DO
	    

!---------- now calculate the interference of the voronoi thing with elements from old mesh

	    ptch_loop: DO i_tnc= 1, i_faccnt
	    IF(i_dface(1,i_tnc,i_cnt) == 0) THEN
	      EXIT ptch_loop
	    ELSE

!---------- calculate volume

	      r_nvolume= r_nvolume+ tetra_vol(r_coord(:,i_cnt), &
	                                    r_dcoord(:,i_dface(1,i_tnc,i_cnt)), &
	                                    r_dcoord(:,i_dface(2,i_tnc,i_cnt)), &
					    r_dcoord(:,i_dface(3,i_tnc,i_cnt)))

!---------- the upstream dual element's outer nodes
	      DO i_dimcnt = 1, GRID_dimension
	        r_vertx(i_dimcnt,2)= r_dcoord(i_dimcnt,i_dface(1,i_tnc,i_cnt))- r_dalpha(i_dimcnt,i_dface(1,i_tnc,i_cnt))
	        r_vertx(i_dimcnt,3)= r_dcoord(i_dimcnt,i_dface(2,i_tnc,i_cnt))- r_dalpha(i_dimcnt,i_dface(2,i_tnc,i_cnt))
	        r_vertx(i_dimcnt,4)= r_dcoord(i_dimcnt,i_dface(3,i_tnc,i_cnt))- r_dalpha(i_dimcnt,i_dface(3,i_tnc,i_cnt))
	      END DO

!---------- calculate integral with quadrature rule

	      CALL tetra_quadrature1(p_mesh(i_time), r_vertx, r_intgrl)
	      r_val= r_val+ r_intgrl

	    END IF
	    END DO ptch_loop

!---------- now calculate concentration

	    r_rside(i_cnt)= r_val/r_nvolume

	  END DO node_loop
	  WRITE(*,*) ' '

 1000	  FORMAT(1x,'INFO: Subroutine [slm_aupstream] accomplished % of work',/ &
                 1x,'0% |------------------------------------------------| 100% ',/ &
		 1x,'   ')
 1010	  FORMAT('#')
	  RETURN
	  END SUBROUTINE slm_aupstream
	  
!*****************************************************************
 	  FUNCTION tetra_vol(r_coord1, r_coord2, r_coord3, r_coord4) RESULT (r_volume)

!---------- local declarations

	  IMPLICIT NONE

	  REAL, DIMENSION(GRID_dimension), INTENT(in) :: r_coord1, r_coord2, r_coord3, r_coord4
	  REAL                                        :: r_volume
	  REAL, DIMENSION(GRID_dimension)             :: r_a, r_b, r_c, r_tmp


!----------    check dimension
	  if  (GRID_dimension/=3) then
	    CALL grid_error(c_error='[tetra_vol]: This is the 3D-version')
	  end if

!---------- calculate vector components

	  r_a= r_coord2- r_coord1
	  r_b= r_coord3- r_coord1
	  r_c= r_coord4- r_coord1

!---------- calculate cross product vector

	  r_tmp= cross_prod(r_b, r_c)
	  

!---------- calculate volume of a tetrahedron: V = 1/6* <r_a,  (r_b x r_c)>

	  r_volume = ABS(DOT_PRODUCT(r_a, r_tmp) / 6.)

	  RETURN
	  END FUNCTION tetra_vol
!*****************************************************************

        FUNCTION cross_prod(r_a, r_b) RESULT (r_result)

!---------- local declarations

        IMPLICIT NONE

	REAL, DIMENSION(3), INTENT(in)			:: r_a, r_b
	REAL, DIMENSION(3)				:: r_result


!---------- calculate the cross product of two given vectors r_a and r_b

	r_result(1) 	= (r_a(2)*r_b(3)) - (r_a(3)*r_b(2))
	r_result(2)	= (r_a(3)*r_b(1)) - (r_a(1)*r_b(3))
	r_result(3)	= (r_a(1)*r_b(2)) - (r_a(2)*r_b(1))
	
	RETURN
	
        END FUNCTION cross_prod

!*****************************************************************
	SUBROUTINE tetra_quadrature(p_mesh, r_vertcoo, r_intgrl)

!---------- local declarations

	IMPLICIT NONE

	TYPE (grid_handle)                             :: p_mesh
	REAL, DIMENSION(GRID_dimension,4), INTENT(in)  :: r_vertcoo
	REAL, INTENT(out)			       :: r_intgrl

	REAL					       :: r_denominator=1./240.
	REAL					       :: r_onethird= 1./3.
	REAL					       :: r_volume
	REAL, DIMENSION(GRID_dimension) 	       :: r_quadpoint
	REAL, DIMENSION(8)			       :: r_vals
	INTEGER                                        :: i_nodecnt

!---------- tetra quadrature of third order according to H. Engels, Numerical Quadrature and Cubature, pp. 283f.

!---------- preinitialize

	r_intgrl = 0.
	  
	  
!---------- calculate volume

	r_volume = tetra_vol(r_vertcoo(:,1), r_vertcoo(:,2), r_vertcoo(:,3), r_vertcoo(:,4))

!---------- calculate interpolation values at quadpoints

	DO i_nodecnt= 1, 4
	  r_quadpoint=r_vertcoo(:,i_nodecnt)
	  r_vals(i_nodecnt)= grid_coordvalue(p_mesh, r_quadpoint, &
	                              i_interpolorder=GRID_highorder)
	END DO


	r_quadpoint=(r_vertcoo(:,1)+ r_vertcoo(:,2)+ r_vertcoo(:,3))* r_onethird
	r_vals(5)= grid_coordvalue(p_mesh, r_quadpoint, &
	                           i_interpolorder=GRID_highorder)

	r_quadpoint=(r_vertcoo(:,1)+ r_vertcoo(:,2)+ r_vertcoo(:,4))* r_onethird
	r_vals(6)= grid_coordvalue(p_mesh, r_quadpoint, &
	                           i_interpolorder=GRID_highorder)

	r_quadpoint=(r_vertcoo(:,1)+ r_vertcoo(:,3)+ r_vertcoo(:,4))* r_onethird
	r_vals(7)= grid_coordvalue(p_mesh, r_quadpoint, &
	                           i_interpolorder=GRID_highorder)

	r_quadpoint=(r_vertcoo(:,2)+ r_vertcoo(:,3)+ r_vertcoo(:,4))* r_onethird
	r_vals(8)= grid_coordvalue(p_mesh, r_quadpoint, &
	                           i_interpolorder=GRID_highorder)
				     

!---------- calculate integral with third order quadrature rule
	DO i_nodecnt= 1, 4
	  r_intgrl= r_intgrl + r_denominator * r_vals(i_nodecnt)
	END DO
	DO i_nodecnt= 5, 8
	  r_intgrl= r_intgrl + r_denominator * (9* r_vals(i_nodecnt))
	END DO

	r_intgrl= r_intgrl *r_volume

	RETURN
	
	END SUBROUTINE tetra_quadrature
      
!*****************************************************************
	SUBROUTINE tetra_quadrature1(p_mesh, r_vertcoo, r_intgrl)

!---------- local declarations

	IMPLICIT NONE

	TYPE (grid_handle)                             :: p_mesh
	REAL, DIMENSION(GRID_dimension,4), INTENT(in)  :: r_vertcoo
	REAL, INTENT(out)			       :: r_intgrl

	REAL					       :: r_onequart= 1./4.
	REAL					       :: r_volume
	REAL, DIMENSION(GRID_dimension) 	       :: r_quadpoint
	REAL                                           :: r_val
	INTEGER                                        :: i_nodecnt

!---------- tetra quadrature of first order according to L. Mentrup and J. Behrens :-)

!---------- preinitialize

	r_intgrl = 0.
	  	  
!---------- calculate volume

	r_volume = tetra_vol(r_vertcoo(:,1), r_vertcoo(:,2), r_vertcoo(:,3), r_vertcoo(:,4))

!---------- calculate interpolation values at quadpoints
	
	r_quadpoint(:)= (r_vertcoo(:,1)+ r_vertcoo(:,2)+ r_vertcoo(:,3)+ r_vertcoo(:,4))* r_onequart
	r_val= grid_coordvalue(p_mesh, r_quadpoint, i_interpolorder=GRID_highorder)
	r_intgrl= r_val *r_volume

	RETURN
	
	END SUBROUTINE tetra_quadrature1
      

	END MODULE SLM_advanced
